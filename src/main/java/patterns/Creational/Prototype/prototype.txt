Prototype Pattern is a creational design pattern used when object creation is expensive or complex, and we want to create new objects by copying an existing object instead of creating one from scratch.

Instead of using new, we:

Create a prototype object

Clone it

Modify the clone as needed

Key idea:

Create new objects by copying existing ones.

âœ” Prototype = object that knows how to clone itself
âœ” Registry = stores different prototype objects
âœ” Registry returns clone, not original
âœ” Clone creates a new object with copied state
If an object has private state, it must own its cloning logic.

Thatâ€™s why each object creates a clone of itself.
ection must be cloneable (very important)
If a field is mutable, you must create a new instance of it while cloning.

Final Mental Checklist for Prototype

When writing clone() always ask:

â“ Is this field mutable?

â“ If yes â†’ create a new object

â“ Does this object itself need cloning?

If you follow this, youâ€™ll never mess up Prototype again.
prototype is used with composite nd decorator patterns
Object.clone()

objects having majority of their state as immutable ar good choices for this design pattern

Sure ğŸ‘
Here is a **clean, concise bullet-point summary** of everything we discussed â€” perfect for **revision, notes, or interviews**.

---

## ğŸ§¬ Prototype Pattern â€“ Key Concepts (Bullet Notes)

### ğŸ”¹ What is a Prototype?

* A prototype is a **pre-configured object** used as a template.
* New objects are created by **cloning** the prototype instead of using `new`.

---

### ğŸ”¹ Why objects clone themselves
* Only the object knows its **internal structure**.
* Preserves **encapsulation**.
* Enables **polymorphic cloning**.
* Avoids `if-else` or type checks.
---

### ğŸ”¹ What does â€œinitialize the cloneâ€ mean?

* Clone must be returned in a **clean, valid state**.
* Copy only **business data**.
* Reset or reinitialize **runtime/transient fields** before returning.

---

### ğŸ”¹ Runtime fields (must be reset, not copied)

* Execution state flags (`connected`, `initialized`, `inProgress`)
* Temporary counters (`retryCount`)
* Timestamps (`lastAccessedTime`)
* Runtime IDs (`sessionId`)
* Cached data (`cache`)
* Live resources (`Socket`, `DB connection`, `Thread`)

---

### ğŸ”¹ Shallow Copy

* Copies **references**, not objects.
* Safe only for **immutable fields**.
* Examples:

  * primitives
  * `String`
  * `LocalDate`
  * other immutable objects

---

### ğŸ”¹ Deep Copy

* Creates **new instances** of mutable fields.
* Required for:

  * `List`, `Map`, `Set`
  * Arrays
  * Custom mutable objects
* Prevents shared state between prototype and clone.

---

### ğŸ”¹ Immutable vs Mutable (Rule)

* **Immutable â†’ shallow copy is safe**
* **Mutable â†’ deep copy is required**

---

### ğŸ”¹ Prototype Registry

* Stores **prototype instances**.
* Returns **clones**, never originals.
* Client never uses `new`.

---

### ğŸ”¹ Common Prototype Mistakes

* Mutating and returning `this` in `clone()`
* Returning original object from registry
* Shallow-copying collections
* Copying runtime fields
* Centralizing clone logic outside the object

---

### ğŸ”¹ Interview-ready one-liners

* *Prototype creates objects by cloning existing ones.*
* *Shallow copy copies references; deep copy copies objects.*
* *Runtime fields should be reset during cloning.*
* *Mutable fields require deep copy; immutable fields donâ€™t.*

---

If you want, I can next:

* Compress this into a **1-page cheat sheet**
* Convert it into **handwritten-style notes**
* Move on to **Strategy / Observer behavioral patterns**

Just tell me ğŸ‘
